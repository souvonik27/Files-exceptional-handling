# -*- coding: utf-8 -*-
"""Files, exceptional handling assignment:

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JCuZ66DaUSwhDNbCpxFCUmJKgaMcidLu

# Files, exceptional handling,
# logging and memory
# management theory and practical questions and answers:

1. What is the difference between interpreted and compiled languages?

-- Compiled languages translate the entire source code into machine code before execution, resulting in faster performance but requiring a compilation step (e.g., C, C++). Interpreted languages, on the other hand, execute code line by line using an interpreter, making them easier to test and modify but generally slower (e.g., Python, JavaScript).

2. What is exception handling in Python?

-- Exception handling in Python is a way to manage errors that occur during program execution without crashing the entire program. It uses keywords like `try`, `except`, `else`, and `finally` to catch and handle exceptions gracefully. The code inside the `try` block runs first, and if an error occurs, it’s caught by the `except` block; `else` runs if no error occurs, and `finally` runs no matter what—useful for cleanup tasks.

3. What is the purpose of the finally block in exception handling?

-- The `finally` block in Python is used to execute code **no matter what happens**—whether an exception occurs or not. It’s typically used for cleanup actions like closing files, releasing resources, or disconnecting from a database, ensuring that essential tasks run even if an error interrupts the program.

4. What is logging in Python?

-- Logging in Python is the process of recording events, errors, and status messages from a program to help monitor its behavior and diagnose issues. The built-in `logging` module lets you track what’s happening in your code by writing logs to the console or a file, using levels like `DEBUG`, `INFO`, `WARNING`, `ERROR`, and `CRITICAL` to indicate the importance of each message.

5. What is the significance of the __del__ method in Python?

-- The `__del__` method in Python is a **destructor** that’s automatically called when an object is about to be destroyed or garbage-collected. It’s mainly used to perform cleanup tasks—like closing files or releasing external resources—before the object is removed from memory. However, it should be used sparingly since Python’s garbage collection may delay or skip calling it in some cases.

6. What is the difference between import and from ... import in Python?

-- The `import` statement brings in the **entire module**, requiring you to use the module name to access its functions or variables (e.g., `import math; math.sqrt(4)`).
The `from ... import` statement imports **specific parts** of a module directly into your namespace, letting you use them without the module prefix (e.g., `from math import sqrt; sqrt(4)`).


**7. How can you handle multiple exceptions in Python?**
 -- In Python, you can handle multiple exceptions by using several `except` blocks, each targeting a specific exception type, or by catching multiple exceptions in a single `except` using parentheses. This allows you to respond differently depending on the error, making your code more robust and easier to debug, while preventing the program from crashing when unexpected issues arise.

**8. What is the purpose of the with statement when handling files in Python?**
 -- The `with` statement is used to simplify file handling by automatically opening and closing a file. It ensures that the file is properly closed after the block of code is executed, even if an exception occurs, which helps prevent resource leaks and makes the code cleaner and safer compared to manually calling `file.close()`.

**9. What is the difference between multithreading and multiprocessing?**
 -- Multithreading runs multiple threads within the same process and shares memory, making it suitable for I/O-bound tasks, while multiprocessing creates separate processes with independent memory spaces, ideal for CPU-bound tasks. The choice affects performance, resource usage, and how data is shared or synchronized between tasks.

**10. What are the advantages of using logging in a program?**
 -- Logging allows a program to record events, errors, and informational messages while it runs, without interrupting its execution. It helps track the flow of execution, debug issues, monitor performance, and maintain records for future analysis. Logging also provides adjustable levels, so critical errors or detailed debug information can be captured selectively.

**11. What is memory management in Python?**
 -- Memory management in Python refers to the automatic allocation and deallocation of memory for objects using reference counting and garbage collection. It ensures that objects no longer in use are removed from memory, freeing resources, preventing leaks, and maintaining the program’s efficiency without requiring manual intervention from the programmer.

**12. What are the basic steps involved in exception handling in Python?**
 -- Exception handling in Python involves wrapping potentially error-prone code in a `try` block, using `except` to catch and respond to errors, `else` to run code if no exception occurs, and `finally` to execute cleanup actions. This structured approach ensures programs handle errors gracefully while maintaining normal operation whenever possible.

**13. Why is memory management important in Python?**
 -- Memory management is crucial because it prevents memory leaks, optimizes performance, and ensures efficient use of system resources. Without proper management, programs could consume excessive memory, slow down, or crash, especially when handling large data structures or long-running applications.

**14. What is the role of try and except in exception handling?**
 -- The `try` block contains code that might raise an exception, while the `except` block defines how to respond to specific errors. This separation allows programs to handle runtime problems gracefully, preventing crashes and enabling developers to log errors, notify users, or recover from unexpected situations.

**15. How does Python's garbage collection system work?**
 -- Python’s garbage collection system automatically manages memory by tracking object references. When an object’s reference count drops to zero, it is deleted. Python also detects and cleans up cyclic references using its cyclic garbage collector. This system ensures efficient memory use without requiring manual deallocation by the programmer.

**16. What is the purpose of the else block in exception handling?**
 -- The `else` block in Python runs only if the `try` block completes without raising any exceptions. It provides a clean way to separate normal execution code from error-handling code, making the program more readable and avoiding unnecessary nesting of code within the `try` block.

**17. What are the common logging levels in Python?**
 -- Python’s logging module defines levels such as `DEBUG`, `INFO`, `WARNING`, `ERROR`, and `CRITICAL`, allowing developers to categorize messages by severity. This helps filter logs for troubleshooting, monitoring, and reporting, making it easier to track minor issues or focus on critical failures in large applications.

**18. What is the difference between os.fork() and multiprocessing in Python?**
 -- `os.fork()` creates a child process by duplicating the current process and is limited to Unix systems, while the `multiprocessing` module provides a cross-platform interface to spawn independent processes, manage them, and share data using queues or pipes. Multiprocessing is more versatile and safer for parallel computation in modern Python programs.

**19. What is the importance of closing a file in Python?**
 -- Closing a file releases system resources associated with it and ensures all buffered data is written to disk. Failing to close files can lead to memory leaks, data loss, or file corruption, making proper file management essential for program reliability and system stability.

**20. What is the difference between file.read() and file.readline() in Python?**
 -- `file.read()` reads the entire file or a specified number of bytes at once, while `file.readline()` reads a single line from the file at a time. Using `readline()` is useful for processing large files line by line, reducing memory usage compared to reading the whole file at once.

**21. What is the logging module in Python used for?**
 -- The logging module provides a flexible framework to record messages from a program, including errors, warnings, or general information. It supports multiple output destinations such as console, files, or remote servers, and allows filtering messages by severity level, which is invaluable for debugging and monitoring applications.

**22. What is the os module in Python used for in file handling?**
 -- The `os` module allows Python programs to interact with the operating system, enabling tasks like creating, deleting, and navigating directories, checking file properties, and managing file paths. It provides essential tools for building scripts that manipulate files and directories across platforms.

**23. What are the challenges associated with memory management in Python?**
 -- Challenges include dealing with circular references that the reference counting system cannot free, avoiding memory leaks caused by lingering global objects, and efficiently handling large datasets in memory-intensive applications. Developers must also balance performance and resource usage when objects are created and destroyed frequently.

**24. How do you raise an exception manually in Python?**
 -- You can raise an exception manually using the `raise` keyword followed by an exception type and an optional message, for example, `raise ValueError("Invalid input")`. This allows you to enforce constraints, signal errors explicitly, and control program flow in a structured way.

**25. Why is it important to use multithreading in certain applications?**
 -- Multithreading is important for improving responsiveness and performance in I/O-bound or concurrent tasks, such as web servers, GUI applications, or file operations. By running multiple threads simultaneously, programs can perform tasks without waiting for slower operations to complete, making them faster and more efficient.

# **Practical questions and answers:**

# 1. How can you open a file for writing in Python and write a string to it?
"""

# Answer:
# You can use the 'open' function with mode 'w' to write to a file.
with open("output.txt", "w") as file:
    file.write("Hello, this is a test string.\n")

"""# 2. Write a Python program to read the contents of a file and print each line.

"""

# Answer:
with open("output.txt", "r") as file:
    for line in file:
        print(line.strip())

"""# 3. How would you handle a case where the file doesn't exist while trying to open it for reading?

"""

# Answer:
try:
    with open("nonexistent.txt", "r") as file:
        content = file.read()
except FileNotFoundError:
    print("File does not exist.")

"""# 4. Write a Python script that reads from one file and writes its content to another file.

"""

# Answer:
with open("output.txt", "r") as source, open("copy.txt", "w") as dest:
    for line in source:
        dest.write(line)

"""# 5. How would you catch and handle division by zero error in Python?

"""

# Answer:
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero.")

"""# 6. Write a Python program that logs an error message to a log file when a division by zero exception occurs.

"""

import logging

# Setup logging
logging.basicConfig(filename="error.log", level=logging.ERROR)

try:
    result = 10 / 0
except ZeroDivisionError as e:
    logging.error("Division by zero occurred: %s", e)

"""# 7. How do you log information at different levels (INFO, ERROR, WARNING) in Python using the logging module?

"""

import logging

logging.basicConfig(level=logging.DEBUG)

logging.info("This is an info message.")
logging.warning("This is a warning message.")
logging.error("This is an error message.")

"""# 8. Write a program to handle a file opening error using exception handling.

"""

try:
    with open("missing.txt", "r") as file:
        data = file.read()
except FileNotFoundError:
    print("File not found. Please check the filename.")

"""# 9. How can you read a file line by line and store its content in a list in Python?

"""

lines = []
with open("output.txt", "r") as file:
    lines = file.readlines()
lines = [line.strip() for line in lines]
print(lines)

"""# 10. How can you append data to an existing file in Python?

"""

with open("output.txt", "a") as file:
    file.write("This line is appended.\n")

"""# 11. Write a Python program that uses a try-except block to handle an error when attempting to access a dictionary key that doesn't exist.

"""

my_dict = {"a": 1, "b": 2}
try:
    print(my_dict["c"])
except KeyError:
    print("Key does not exist.")

"""# 12. Write a program that demonstrates using multiple except blocks to handle different types of exceptions.

"""

try:
    x = int("abc")
    result = 10 / 0
except ValueError:
    print("ValueError caught")
except ZeroDivisionError:
    print("ZeroDivisionError caught")

"""# 13. How would you check if a file exists before attempting to read it in Python?

"""

import os

if os.path.exists("output.txt"):
    with open("output.txt", "r") as file:
        print(file.read())
else:
    print("File does not exist.")

"""# 14. Write a program that uses the logging module to log both informational and error messages.

"""

import logging

logging.basicConfig(filename="app.log", level=logging.DEBUG)

logging.info("This is an informational message.")
try:
    result = 10 / 0
except ZeroDivisionError as e:
    logging.error("Error occurred: %s", e)

"""# 15. Write a Python program that prints the content of a file and handles the case when the file is empty.

"""

with open("output.txt", "r") as file:
    content = file.read()
    if content:
        print(content)
    else:
        print("File is empty.")

"""# 16. Demonstrate how to use memory profiling to check the memory usage of a small program.

"""

# You need to install memory-profiler: !pip install memory-profiler
from memory_profiler import memory_usage

def my_function():
    a = [i for i in range(100000)]
    return sum(a)

mem_usage = memory_usage(my_function)
print("Memory usage:", mem_usage)

!pip install memory-profiler

"""# 17. Write a Python program to create and write a list of numbers to a file, one number per line.

"""

numbers = [1, 2, 3, 4, 5]
with open("numbers.txt", "w") as file:
    for num in numbers:
        file.write(f"{num}\n")

"""# 18. How would you implement a basic logging setup that logs to a file with rotation after 1MB?

"""

import logging
from logging.handlers import RotatingFileHandler

handler = RotatingFileHandler("rotating.log", maxBytes=1_000_000, backupCount=3)
logging.basicConfig(handlers=[handler], level=logging.INFO)
logging.info("This is a log message.")

"""# 19. Write a program that handles both IndexError and KeyError using a try-except block.

"""

my_list = [1, 2, 3]
my_dict = {"a": 10}

try:
    print(my_list[5])
    print(my_dict["b"])
except IndexError:
    print("IndexError caught")
except KeyError:
    print("KeyError caught")

"""# 20. How would you open a file and read its contents using a context manager in Python?

"""

with open("output.txt", "r") as file:
    content = file.read()
    print(content)

"""# 21. Write a Python program that reads a file and prints the number of occurrences of a specific word.

"""

word_count = 0
target_word = "Hello"
with open("output.txt", "r") as file:
    for line in file:
        word_count += line.split().count(target_word)
print(f"The word '{target_word}' occurs {word_count} times.")

"""# 22. How can you check if a file is empty before attempting to read its contents?

"""

import os

if os.path.exists("output.txt") and os.path.getsize("output.txt") > 0:
    with open("output.txt", "r") as file:
        print(file.read())
else:
    print("File is empty or does not exist.")

"""# 23. Write a Python program that writes to a log file when an error occurs during file handling.

"""

import logging

logging.basicConfig(filename="file_error.log", level=logging.ERROR)

try:
    with open("missing.txt", "r") as file:
        content = file.read()
except Exception as e:
    logging.error("An error occurred while handling the file: %s", e)